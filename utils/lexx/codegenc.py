from nfa import *
from dfa import *
from collections import defaultdict

class Action:
    def __init__(self, text, where = None):
        self.text = text
        self.where = where
        self.used = False

    def __str__(self):
        if self.where <> None:
            return self.where
        else:
            return self.text

class CodeEmmiter:
    def __init__(self, f):
        self.f = f
        self.level = 0
        self.empty_str = True

    def indent(self):
        self.level = self.level + 1

    def unindent(self):
        self.level = self.level - 1

    def write(self, s):
        lines = s.split('\n')
        if len(lines) > 0:
            for line in lines[:-1]:
                self._write(line)
                self.f.write('\n')
                self.empty_str = True
            self._write(lines[-1])
        
    def _write(self, line):
        if len(line) > 0:
            if self.empty_str:
                self.write_indent()
            self.f.write(line)
            self.empty_str = False

    def write_indent(self):
        self.f.write('\t' * self.level)
            

class CodegenC:
    def __init__(self):
        self.prologue = ""
        self.states = set(["INITIAL"])
        self.eof_actions = dict()
        self.action_nfas = dict()
        self.state_nfas = dict()
        self.state_dfas = dict()

        self.fun_name = "lexx_run"

    def set_prologue(self, prologue):
        self.prologue = prologue

    def add_state(self, state):
        if state in self.states:
            raise Exception("Duplicate state {}".format(state))
        self.states.add(state)

    def add_state_eof_action(self, state, action):
        if state not in self.states:
            raise Exception("State {} not defined but has eof action".format(state))
        if state in self.eof_actions:
            raise Exception("Duplicate eof action for state {}".format(state))
        self.eof_actions[state] = action

    def add_action(self, state, re, action):
        end_nfa = self.get_nfa_for_action(action)
        start_nfa = self.get_nfa_for_state(state)
        re_to_nfa(re, start_nfa, end_nfa)

    def get_nfa_for_action(self, action):
        if action not in self.action_nfas:
            action.order = len(self.action_nfas)
            self.action_nfas[action] = NFAState(action)
        return self.action_nfas[action]

    def get_nfa_for_state(self, state):
        if state not in self.states:
            raise Exception("State {} not defined".format(state))
        if state not in self.state_nfas:
            self.state_nfas[state] = NFAState()
        return self.state_nfas[state]

    def generate(self):
        for k, v in self.state_nfas.iteritems():
            print "Building dfa for state {}".format(k)            
            self.state_dfas[k] = minimize_dfa(NFA2DFASet().convert_nfa(v))
            dfas = set()
            find_dfas(self.state_dfas[k], dfas)
            for dfa in dfas:
                if len(dfa.finals) > 0:
                    self.priority_final(dfa.finals).used = True

        for act in self.action_nfas:
            if not act.used:
                print "Warning: Action {0} is useless".format(act)
            
    def priority_final(self, finals):
        return sorted(finals, key=lambda x:x.order)[0]

    def emmit(self, output):
        self.emmiter = CodeEmmiter(output)
        def write(s):
            self.emmiter.write(s)
        def writeln(s):
            self.emmiter.write(s + "\n")
        writeln("/*** Generated by LEXX. Do not edit ***/\n")
        writeln(self.prologue)
        writeln("\n")
        writeln("typedef unsigned char lexx_byte;")
        writeln("typedef size_t lexx_size;")

        writeln("#define lexem_length (data - lexem_start)")

        writeln("#define LEXX_UNPUT(n) (data -= n)")
        writeln("#define LEXX_GOTO(state) goto state")

        writeln("#if !defined(LEXX_CONSUME_UNEXPECTED)")
        writeln("#define LEXX_CONSUME_UNEXPECTED")
        writeln("#endif")

        writeln("#if !defined(LEXX_USERPARAM)")
        writeln("#define LEXX_USERPARAM")
        writeln("#endif")
        
        writeln("\nvoid " + self.fun_name + "(LEXX_USERPARAM const lexx_byte* data, lexx_size size){")
        self.emmiter.indent()
        writeln("const lexx_byte* data_end = data + size;")
        writeln("const lexx_byte* lexem_start = data;")

        writeln("goto INITIAL;")

        for state, start_dfa in self.state_dfas.iteritems():
            writeln("{0}:".format(state))
            writeln("lexem_start = data;")
            dfas = set()
            find_dfas(start_dfa, dfas)
            next_id = 1
            for dfa in dfas:
                dfa.id = next_id
                next_id = next_id + 1
            writeln("goto {0}_{1};".format(state, start_dfa.id))
            for dfa in dfas:
                can_come_nonconsumed = dfa == start_dfa
                
                writeln("{0}_{1}:".format(state, dfa.id))
                self.emmiter.indent()
                writeln("switch(*data){")
                writeln("case 0:{")
                self.emmiter.indent()
                writeln("if ( data == data_end ){")
                self.emmiter.indent()

                if can_come_nonconsumed:
                    #no tokens consumed
                    if state in self.eof_actions:
                        writeln(self.eof_actions[state].text)
                        writeln("return;")
                    else:
                        writeln("return;")
                else:
                    #some tokens are consumed
                    #finalize token here
                    if len(dfa.finals) == 0:
                        writeln("LEXX_CONSUME_UNEXPECTED;")                    
                        writeln("goto {0};".format(state))
                    else:
                        final = self.priority_final(dfa.finals)
                        writeln(final.text)
                        writeln("goto {0};".format(state))

                self.emmiter.unindent()
                writeln("}else{")
                self.emmiter.indent()
                #ordinary zero character
                if 0 in dfa.transitions:
                    writeln("data++;")
                    writeln("goto {0}_{1};".format(state, dfa.transitions[0].id))
                elif len(dfa.finals) == 0:
                    if can_come_nonconsumed:
                        writeln("data++;")
                        writeln("LEXX_CONSUME_UNEXPECTED;")
                        writeln("goto {0};".format(state))
                    else:
                        writeln("LEXX_CONSUME_UNEXPECTED;")                    
                        writeln("goto {0};".format(state))
                else:
                    final = self.priority_final(dfa.finals)
                    writeln(final.text)
                    writeln("goto {0};".format(state))
                self.emmiter.unindent()
                writeln("}")
                self.emmiter.unindent()
                writeln("}break;")

                groups = defaultdict(lambda: [])
                for k,v in dfa.transitions.iteritems():
                    groups[v].append(k)

                for k,v in groups.iteritems():
                    for ch in v:
                        if ch <> 0:
                            write("case {0}:".format(ch))
                    writeln("{")
                    writeln("data++;")
                    writeln("goto {0}_{1};".format(state, k.id))
                    writeln("}break;")

                if len(dfa.transitions) < 256:
                    writeln("default:{")
                    self.emmiter.indent()
                    if len(dfa.finals) == 0:
                        if can_come_nonconsumed:
                            writeln("data++;")
                            writeln("LEXX_CONSUME_UNEXPECTED;")
                            writeln("goto {0};".format(state))
                        else:
                            writeln("LEXX_CONSUME_UNEXPECTED;")                    
                            writeln("goto {0};".format(state))
                    else:
                        final = self.priority_final(dfa.finals)
                        writeln(final.text)
                        writeln("goto {0};".format(state))                    
                    self.emmiter.unindent()
                    writeln("}break;")

                writeln("}")
                self.emmiter.unindent()
        
        self.emmiter.unindent()
        writeln("}")
